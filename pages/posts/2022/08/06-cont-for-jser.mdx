export const metadata = {
  title: "JavaScriptプログラマのための継続、モナド、algebraic effects",
  description:
    "継続、モナドといった概念はJavaScriptプログラマも意識せず利用している。その一端を解説しよう。",
};

# はじめに

これからのプログラミングにおいて流行ると思われる概念に **代数的エフェクト** (algebraic effects) がある。JavaScript プログラマにとっては React Suspense の発想の元ネタであるという印象が強いだろう。

代数的エフェクトは **継続** (continuation) と切って離せない機能だ。「継続は力なり」という言葉が示すように継続は強力な機能であり、みんな大好き **モナド** (monad) とも深い関わりがある。

この記事では JavaScript を学んだことのあるプログラマを対象に、継続とモナドについて解説していく。

# 継続渡し

加算をする関数を考えよう。

```
const add = (x, y) => x + y;
```

ここで、加算をした結果を加算に使いたいとする。

```
const x = add(1, 2);
const y = add(x, x); // 6
console.log(y);
```

関数を呼び出して結果を受け取り、その値を関数にまた渡す。ごくふつうの JavaScript プログラムだ。

実は、変数宣言を使わずにこれと等価なプログラムを書くことができる。

```
const addC = (x, y, k) => k(x + y);
add(1, 2, x =>
  add(x, x, y => {
    console.log(y);
  })
);
```

インデントだらけのかなり狂った、しかし既視感のある形が現れた。往年の Node.js プログラマであれば見たことがあるだろう。そう、コールバックによる非同期処理である。

```

```

これを継続渡しスタイル (continuation passing style, CPS) とよぶ。プログラミング言語処理系の内部表現として使われることもある。

一見継続渡しスタイルは読みづらいだけの無用なスタイルだ。いや、コードを書く際には実際そうなのだが、これには利点がある。`add` が継続、すなわち「`add` の処理が終わったあとの処理」を握っているところがポイントだ。継続は `addC` から見ればただの関数なので、2 回呼び出すこともできるし、捨てることもできる。非同期的に呼び出してもよいだろう。

```
const addC2 = (x, y, k) => setTimeout(() => k(x + y), 1000);
```

Node.js のコールバックも、継続をイベントループに送っていると考えることができる。

# ジェネレータ

ジェネレータという便利な機能がある。ざっくりとした説明としては中断できる関数を使ってイテレータを簡単に書けるというものだが、これも継続がかかわる。

```
function* gen() {
  const a = yield;
  return a;
}
```

ジェネレータの実行中、ジェネレータ関数のコードは `yield` にさしかかるたび停止し、ジェネレータ使用者による `g.next()` メソッドを待つ。つまり `g.next()` は継続を呼び出す効果を持っているといえる。たとえばジェネレータを使う側で非同期に呼んでみよう。

```
const g = gen();
setTimeout(() => g.next(), 1000);
```

ジェネレータ関数は非同期的に再開されることになる。コールバックで CPS を構築したのと同じように継続を扱うことができた。しかも、関数を繋げるのではなく変数宣言の連続のように書けていてネストが少なく嬉しい。コールバックが同期的っぽく書けて嬉しいといえば？そう、**async/await** である。

async/await をジェネレータ関数で再現できるのは「ハンズオン Node.js」に示されている。

ところで `yield` はまるで関数のように扱えるが、それが実際に行う処理はジェネレータの使用側が決めることだ。ジェネレータ関数はただ `yield` に値を渡し、同期的だか非同期的だか知らないが値が返ってくるのを待つ。もしかしたらその時は永遠に来ないかもしれない。この考えかたは algebraic effects の特徴そのものでもある。

このジェネレータ関数ではログを出力するのに `yield` を使うとする。ただし実際にログをどこに出力するのか、そもそも出力しないのかは使用者が決める。

```

```

ジェネレータの使用者が `yield` の際の処理を規定することによって、はじめて `yield` の意味が与えられるのだ。そしてそれはジェネレータの使用者を差し替えることによって簡単に切り替えできる。たとえばコンソールではなくファイルに書き込むのでもよい。

algebraic effects はまさにこのような時のための機能だ。ログを出力するというエフェクトを定義し、関数で使う。

エフェクトハンドラとよばれる機構によってログされたときの挙動が規定される。

エフェクトハンドラを切り替えれば `log` の意味が切り替わる。

そういうことで、ジェネレータと代数的エフェクトは相当似ている。どれくらい似ているかというと、Lua や Ruby のジェネレータはある種の代数的エフェクトを模倣できるということが Nymphium 氏によって研究されている。残念ながら JavaScript のジェネレータは若干特性が異なるのでそのまま模倣とはいかないが、相当それっぽいということはわかるだろう。
