export const metadata = {
  title: "関数型という言葉が包含するパラダイム",
  description:
    "関数型プログラミングがどういうプログラミング手法なのか説明しなさい。(10点、部分点あり)",
};

オブジェクト指向と同じように、関数型プログラミングという言葉も一種のバズワードである。

# この記事を読むとどうなるか

関数型という言葉を使わなくなる。

# 純粋性

純粋関数 (pure function) とは、暗黙の入出力をもたない関数のことである。ここで入力とは関数の実行結果に影響を与えるものであり、出力とは関数の実行結果である。明示的な入出力とは関数の引数と返り値のことを指し、裏返して暗黙の入出力とは引数以外の入力と返り値以外の出力を指す。たとえば `printf` `console.log` はコンソールに文字列を書き込むので暗黙的な出力がある。`Date.now` は現在時刻を返す関数だが、呼び出すたびに値が変わるので暗黙的な入力がある。グローバル変数の読み書きや例外を投げることも暗黙的な入出力に入るだろう。

関数型プログラミングにおいてはなるべくロジックを純粋関数に切り出し、暗黙の入出力を外部に分離することが行われる。純粋関数には **同じ引数を与えれば必ず同じ結果が返る** といううれしい性質があり、純粋関数はその挙動を予測しやすく、テストがしやすい。その極致といえるのが純粋関数型言語である Haskell, Elm, PureScript, Nix であり、これらの言語ではあらゆる関数がまったく副作用をもたない。

できるだけ暗黙の入出力を減らそうという試みは関数型言語に限ったことではない。C などでもグローバル変数を読み書きすることはできるだけ避けられるし、純粋関数に切り出すということは関数型言語といわれる言語でなくてもある程度は実践できる。しかし、とくに例外がある言語では言語全体としてエラー時にバンバン例外を投げる設計や文化になっていることがまれによくあり、純粋性を担保することが面倒だったりする。Java とか JavaScript がそれなのだが、実は純粋関数型言語であるはずの Haskell もそちら側で、たとえばリストの先頭を得る関数 `head` を空リストに対して使用するといきなり例外が発射されて死ぬ。ある関数の処理中で例外が発生した場合でも `catch` でいい感じにハンドリングすればその関数自体は純粋にできる。返り値で成功と失敗を表すことで純粋なままエラー処理を行える言語というのもあり、Rust や OCaml の `Option` `Result` や Kotlin の null 許容型、TypeScript の union、Haskell の `Maybe` `Either` がそれにあたる。

# 不変性

関数型プログラミングにおいては不変 (immutable) に扱われることが多い。

手続き型プログラミングにおいて変数などを書き換えることはとてもよく行われる。C などによくある手続き型のループを考えよう。

```rust
let mut i = 0;

while i < 10 {
  println!("{}", i);
  i += 1;
}
```

はじめにループの状態を保存する変数が `0` で初期化され、毎回のループで `i++` が実行されることによってその値が 1 ずつ増えていく。

同じコードを関数の再帰呼び出しに書き換えてみると以下のようになる。

```rust
fn f(i: i32=0) {
  if i < 10 {
    println!("{}", i);
    f(i + 1);
  }
}
```

Scala や Kotlin は不変に `val`、可変に `var` を使う。Rust は不変に `let`、可変に `let mut` を使う。まず不変があり、可変は特殊な場合であるという思想がわかる。
